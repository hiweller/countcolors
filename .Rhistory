get.indicator <- FALSE
}
# If range = "spherical", check that center and radius are specified and are
# coercible to appropriate formats
if (tolower(color.range) == "spherical") {
# Check that center and radius were specified and are of appropriate types
if (!exists("center") | !exists("radius")) {
stop("Center and radius must be specified for a spherical color range")
}
# Make sure that center is of appropriate format (divisible by 3/matrix with
# 3 columns)
if (is.vector(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# And make sure everything is in the 0-1 range; if not, assume 0-255 and
# divide by 255
if (range(center)[2] > 1) {
center <- center / 255
}
# Make sure that an appropriate number of radii were provided
if (nrow(center) != length(radius)) {
stop("Number of centers and radii differ")
}
# If everything checks out, print the centers/radii being screened
message("Using spherical range(s):")
for (i in 1:nrow(center)) {
message(paste("Center: ", paste(center[i, ], collapse = ", "),
" +/- ", radius[i] * 100, "%", sep = ""))
}
# Perform similar check for center colors
if (is.numeric(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# Make sure there are enough colors to use for color indexing; if not, just
# repeat color vector
if (length(target.color) < nrow(center)) {
target.color <- rep(target.color, round(nrow(center) /
length(target.color)) + 1)
}
# Get range using first color
filtered.img <- sphericalRange(pixel.array = original, center = center[1, ],
radius = radius[1], plotting = FALSE,
color.pixels = get.indicator,
target.color = target.color[1])
idx <- filtered.img$pixel.idx
# Keep the indicator image (color inside pixel range changed to indicator
# color) and pixel indices for later display
if (get.indicator) {
indicator.img <- filtered.img$indicator.img
}
# If more than one center/radius pair were specified, screen for each color
# in turn, but do the color indexing on the same image so we can see
# everything that is being counted
if (nrow(center) > 1) {
for (i in 2:nrow(center)) {
filtered.img <- sphericalRange(pixel.array = original,
center = center[i, ], radius = radius[i],
plotting = FALSE, color.pixels = FALSE)
if (get.indicator) {
indicator.img <- changePixelColor(indicator.img,
filtered.img$pixel.idx,
target.color = target.color[i],
return.img = TRUE, plotting = FALSE)
}
idx <- rbind(idx, filtered.img$pixel.idx)
}
}
} else if (tolower(color.range) == "rectangular") {
# If range is set to rectangular, perform similar checks
# Check that lower and upper ranges were specified
if (!exists("lower") | !exists("upper")) {
stop("Lower and upper ranges must be specified for
a rectangular color range")
}
# Make sure that lower bounds are of appropriate format (divisible by
# 3/matrix with 3 columns)
if (is.vector(lower)) {
if (length(lower) %% 3 == 0) {
lower <- matrix(lower, ncol = 3, byrow = TRUE)
} else {
stop("Lower must be a vector with length a multiple of 3
or a matrix of lower bounds")
}
} else if (is.matrix(lower)) {
if (ncol(lower) != 3) {
stop("Lower bounds matrix must have 3 columns, 1 per channel")
}
}
# Same with upper; there is probably a more elegant way to do this than just
# doing both separately... probably with quote/eval, but the variable
# reassignment makes me itchy
if (is.vector(upper)) {
if (length(upper) %% 3 == 0) {
upper <- matrix(upper, ncol = 3, byrow = TRUE)
} else {
stop("Upper must be a vector with length a multiple of 3
or a matrix of lower bounds")
}
} else if (is.matrix(upper)) {
if (ncol(upper) != 3) {
stop("Upper bounds matrix must have 3 columns, 1 per channel")
}
}
# Make sure that the same number of upper and lower bounds were provided
if (nrow(lower) != nrow(upper)) {
stop("Number of lower and upper bounds differs")
}
# And make sure everything is in the 0-1 range; if not, assume 0-255 and
# divide by 255
if (range(lower)[2] > 1 | range(upper)[2] > 1) {
lower <- lower / 255
upper <- upper / 255
}
message("Using rectangular bound(s):")
for (i in 1:nrow(lower)) {
message(paste("R: ", paste(lower[i, 1], "-", upper[i, 1], sep = ""),
"; G: ", paste(lower[i, 2], "-", upper[i, 2], sep = ""),
"; B: ", paste(lower[i, 3], "-", upper[i, 3], sep = ""),
sep = ""))
}
# Get range using first color
filtered.img <- rectangularRange(pixel.array = original, lower = lower[1, ],
upper = upper[1, ], plotting = FALSE,
color.pixels = get.indicator,
target.color = target.color[1])
idx <- filtered.img$pixel.idx
if (get.indicator) {
indicator.img <- filtered.img$indicator.img
}
# If more than one lower/upper bound pair were specified, repeat the process
# over increasingly filtered images
if (nrow(lower) > 1) {
for (i in 2:nrow(lower)) {
filtered.img <- rectangularRange(pixel.array = original,
lower = lower[i, ], upper = upper[i, ],
plotting = FALSE, color.pixels = FALSE)
if (get.indicator) {
indicator.img <- changePixelColor(indicator.img,
filtered.img$pixel.idx,
target.color = target.color[i],
return.img = TRUE, plotting = FALSE)
}
idx <- rbind(idx, filtered.img$pixel.idx)
}
}
}
radii
radius
radius <- c(0.15, 0.1)
# If range = "spherical", check that center and radius are specified and are
# coercible to appropriate formats
if (tolower(color.range) == "spherical") {
# Check that center and radius were specified and are of appropriate types
if (!exists("center") | !exists("radius")) {
stop("Center and radius must be specified for a spherical color range")
}
# Make sure that center is of appropriate format (divisible by 3/matrix with
# 3 columns)
if (is.vector(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# And make sure everything is in the 0-1 range; if not, assume 0-255 and
# divide by 255
if (range(center)[2] > 1) {
center <- center / 255
}
# Make sure that an appropriate number of radii were provided
if (nrow(center) != length(radius)) {
stop("Number of centers and radii differ")
}
# If everything checks out, print the centers/radii being screened
message("Using spherical range(s):")
for (i in 1:nrow(center)) {
message(paste("Center: ", paste(center[i, ], collapse = ", "),
" +/- ", radius[i] * 100, "%", sep = ""))
}
# Perform similar check for center colors
if (is.numeric(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# Make sure there are enough colors to use for color indexing; if not, just
# repeat color vector
if (length(target.color) < nrow(center)) {
target.color <- rep(target.color, round(nrow(center) /
length(target.color)) + 1)
}
# Get range using first color
filtered.img <- sphericalRange(pixel.array = original, center = center[1, ],
radius = radius[1], plotting = FALSE,
color.pixels = get.indicator,
target.color = target.color[1])
idx <- filtered.img$pixel.idx
# Keep the indicator image (color inside pixel range changed to indicator
# color) and pixel indices for later display
if (get.indicator) {
indicator.img <- filtered.img$indicator.img
}
# If more than one center/radius pair were specified, screen for each color
# in turn, but do the color indexing on the same image so we can see
# everything that is being counted
if (nrow(center) > 1) {
for (i in 2:nrow(center)) {
filtered.img <- sphericalRange(pixel.array = original,
center = center[i, ], radius = radius[i],
plotting = FALSE, color.pixels = FALSE)
if (get.indicator) {
indicator.img <- changePixelColor(indicator.img,
filtered.img$pixel.idx,
target.color = target.color[i],
return.img = TRUE, plotting = FALSE)
}
idx <- rbind(idx, filtered.img$pixel.idx)
}
}
} else if (tolower(color.range) == "rectangular") {
# If range is set to rectangular, perform similar checks
# Check that lower and upper ranges were specified
if (!exists("lower") | !exists("upper")) {
stop("Lower and upper ranges must be specified for
a rectangular color range")
}
# Make sure that lower bounds are of appropriate format (divisible by
# 3/matrix with 3 columns)
if (is.vector(lower)) {
if (length(lower) %% 3 == 0) {
lower <- matrix(lower, ncol = 3, byrow = TRUE)
} else {
stop("Lower must be a vector with length a multiple of 3
or a matrix of lower bounds")
}
} else if (is.matrix(lower)) {
if (ncol(lower) != 3) {
stop("Lower bounds matrix must have 3 columns, 1 per channel")
}
}
# Same with upper; there is probably a more elegant way to do this than just
# doing both separately... probably with quote/eval, but the variable
# reassignment makes me itchy
if (is.vector(upper)) {
if (length(upper) %% 3 == 0) {
upper <- matrix(upper, ncol = 3, byrow = TRUE)
} else {
stop("Upper must be a vector with length a multiple of 3
or a matrix of lower bounds")
}
} else if (is.matrix(upper)) {
if (ncol(upper) != 3) {
stop("Upper bounds matrix must have 3 columns, 1 per channel")
}
}
# Make sure that the same number of upper and lower bounds were provided
if (nrow(lower) != nrow(upper)) {
stop("Number of lower and upper bounds differs")
}
# And make sure everything is in the 0-1 range; if not, assume 0-255 and
# divide by 255
if (range(lower)[2] > 1 | range(upper)[2] > 1) {
lower <- lower / 255
upper <- upper / 255
}
message("Using rectangular bound(s):")
for (i in 1:nrow(lower)) {
message(paste("R: ", paste(lower[i, 1], "-", upper[i, 1], sep = ""),
"; G: ", paste(lower[i, 2], "-", upper[i, 2], sep = ""),
"; B: ", paste(lower[i, 3], "-", upper[i, 3], sep = ""),
sep = ""))
}
# Get range using first color
filtered.img <- rectangularRange(pixel.array = original, lower = lower[1, ],
upper = upper[1, ], plotting = FALSE,
color.pixels = get.indicator,
target.color = target.color[1])
idx <- filtered.img$pixel.idx
if (get.indicator) {
indicator.img <- filtered.img$indicator.img
}
# If more than one lower/upper bound pair were specified, repeat the process
# over increasingly filtered images
if (nrow(lower) > 1) {
for (i in 2:nrow(lower)) {
filtered.img <- rectangularRange(pixel.array = original,
lower = lower[i, ], upper = upper[i, ],
plotting = FALSE, color.pixels = FALSE)
if (get.indicator) {
indicator.img <- changePixelColor(indicator.img,
filtered.img$pixel.idx,
target.color = target.color[i],
return.img = TRUE, plotting = FALSE)
}
idx <- rbind(idx, filtered.img$pixel.idx)
}
}
}
# Takes a path to an image and loads it
img <- colordistance::loadImage(path, lower = bg.lower, upper = bg.upper)
original <- img$original.rgb
# If saving is on but no path was specified, set it to same directory as
# original image
if (isTRUE(save.indicator)) {
destination <- paste(tools::file_path_sans_ext(path),
"_masked.png", sep = "")
} else if (is.character(save.indicator)) {
# If save.indicator is a filepath, save as a png and set save.indicator to a
# logical value
if (dir.exists(save.indicator)) {
destination <- paste(save.indicator, tools::file_path_sans_ext(path),
".png", sep = "")
} else {
destination <- paste(tools::file_path_sans_ext(save.indicator),
".png", sep = "")
}
save.indicator <- TRUE
}
plotting
get.indicator <- TRUE
# Convert target.color to hex codes for indicator image
# If target.color is color names, convert to RGB matrix
if (is.character(target.color)) {
# convert color names to RGB triplets
target.color <- t(col2rgb(target.color)) / 255
# If vector or matrix, convert to/check for 3-column matrix
} else if (is.numeric(target.color)) {
# If a vector, convert to a matrix
if (is.vector(target.color)) {
if (length(target.color) %% 3 == 0) {
target.color <- matrix(target.color, ncol = 3, byrow = TRUE)
} else {
stop(paste("Target.color must be a vector of color names",
"a vector of RGB triplets (multiple of 3)",
"or a matrix with target.colors as rows",
sep = ", "))
# If already a matrix, check that it has 3 columns
}
} else if (is.matrix(target.color)) {
if (ncol(target.color) != 3) {
stop("target.colors matrix must have 3 columns, 1 per channel")
}
}
}
target.color
# Convert to hex colors
target.color <- apply(target.color, 1,
function(i) rgb(i[1], i[2], i[3]))
target.color
target.color <- c("magenta", "cyan")
get.indicator <- TRUE
# Convert target.color to hex codes for indicator image
# If target.color is color names, convert to RGB matrix
if (is.character(target.color)) {
# convert color names to RGB triplets
target.color <- t(col2rgb(target.color)) / 255
# If vector or matrix, convert to/check for 3-column matrix
} else if (is.numeric(target.color)) {
# If a vector, convert to a matrix
if (is.vector(target.color)) {
if (length(target.color) %% 3 == 0) {
target.color <- matrix(target.color, ncol = 3, byrow = TRUE)
} else {
stop(paste("Target.color must be a vector of color names",
"a vector of RGB triplets (multiple of 3)",
"or a matrix with target.colors as rows",
sep = ", "))
# If already a matrix, check that it has 3 columns
}
} else if (is.matrix(target.color)) {
if (ncol(target.color) != 3) {
stop("target.colors matrix must have 3 columns, 1 per channel")
}
}
}
target.color
# Convert to hex colors
target.color <- apply(target.color, 1,
function(i) rgb(i[1], i[2], i[3]))
target.color
# Check that center and radius were specified and are of appropriate types
if (!exists("center") | !exists("radius")) {
stop("Center and radius must be specified for a spherical color range")
}
# Make sure that center is of appropriate format (divisible by 3/matrix with
# 3 columns)
if (is.vector(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# And make sure everything is in the 0-1 range; if not, assume 0-255 and
# divide by 255
if (range(center)[2] > 1) {
center <- center / 255
}
# Make sure that an appropriate number of radii were provided
if (nrow(center) != length(radius)) {
stop("Number of centers and radii differ")
}
# If everything checks out, print the centers/radii being screened
message("Using spherical range(s):")
for (i in 1:nrow(center)) {
message(paste("Center: ", paste(center[i, ], collapse = ", "),
" +/- ", radius[i] * 100, "%", sep = ""))
}
# Perform similar check for center colors
if (is.numeric(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
# Make sure there are enough colors to use for color indexing; if not, just
# repeat color vector
if (length(target.color) < nrow(center)) {
target.color <- rep(target.color, round(nrow(center) /
length(target.color)) + 1)
}
# Get range using first color
filtered.img <- sphericalRange(pixel.array = original, center = center[1, ],
radius = radius[1], plotting = FALSE,
color.pixels = get.indicator,
target.color = target.color[1])
center[1,]
green.center <- c(0.24, 0.45, 0.24)
green.center
white.center
center = c(green.center, white.center)
center.
center
is.vector(center)
length(center) %% 3 == 0
center <- matrix(center, ncol = 3, byrow = TRUE)
center
# Perform similar check for center colors
if (is.numeric(center)) {
if (length(center) %% 3 == 0) {
center <- matrix(center, ncol = 3, byrow = TRUE)
} else {
stop("Center must be a vector with length a multiple of 3 or a matrix
of centers")
}
} else if (is.matrix(center)) {
if (ncol(center) != 3) {
stop("Centers matrix must have 3 columns, 1 per channel")
}
}
center
two.colors <- countcolors::countColors("norway.jpg", color.range="spherical",
center = c(green.center, white.center), radius = c(0.15, 0.1),
bg.lower=NULL, bg.upper=NULL, plotting = TRUE,
target.color=c("magenta", "cyan"))
library(countcolors)
devtools::build_win()
install.packages("pdflatex")
devtools::build_win()
devtools::check_win()
devtools::check_rhub()
install.packages("revdepcheck")
devtools::install_github("r-lib/revdepcheck")
revdepcheck::revdep_check()
devtools::revdep_check()
devtools::check_rhub()
devtools::release()
devtools::release()
devtools::check_win_devel()
devtools::release()
